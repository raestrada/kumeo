use std::error::Error;
use std::collections::HashMap;
use async_nats::Client as NatsClient;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::{info, error, warn};

/// Router configuration for {{agent_id}}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{agent_id}}Config {
    pub routing_rules: HashMap<String, String>,
    pub default_route: Option<String>,
}

/// Event received from the input topic
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputEvent {
    pub id: String,
    pub data: Value,
    pub metadata: Value,
}

/// {{agent_id}} - Router Agent for {{workflow_name}}
/// Generated by Kumeo compiler
pub struct {{agent_id}}Agent {
    nats_client: NatsClient,
    config: {{agent_id}}Config,
    input_topic: String,
}

impl {{agent_id}}Agent {
    /// Create a new instance of the {{agent_id}}Agent
    pub async fn new(nats_url: &str) -> Result<Self, Box<dyn Error>> {
        let nats_client = async_nats::connect(nats_url).await?;
        
        // Parse routing rules from JSON string
        let routing_rules_json = r#"{{routing_rules}}"#;
        let routing_rules: HashMap<String, String> = serde_json::from_str(routing_rules_json)
            .unwrap_or_else(|_| HashMap::new());
        
        let config = {{agent_id}}Config {
            routing_rules,
            default_route: None,
        };
        
        Ok(Self {
            nats_client,
            config,
            input_topic: String::from("{{input_topic}}"),
        })
    }
    
    /// Start the agent's message processing loop
    pub async fn run(&self) -> Result<(), Box<dyn Error>> {
        info!("Starting {{agent_id}} Router agent for workflow {{workflow_name}}");
        
        // Subscribe to the input topic
        let mut subscriber = self.nats_client.subscribe(&self.input_topic).await?;
        
        // Process messages
        while let Some(msg) = subscriber.next().await {
            if let Err(e) = self.route_message(&msg).await {
                error!("Error routing message: {}", e);
            }
        }
        
        Ok(())
    }
    
    /// Route a message based on the configured rules
    async fn route_message(&self, msg: &async_nats::Message) -> Result<(), Box<dyn Error>> {
        // Parse the input event
        let input: InputEvent = serde_json::from_slice(&msg.payload)?;
        info!("Routing message with ID: {}", input.id);
        
        // Determine the route based on the data
        let route = self.determine_route(&input)?;
        
        if let Some(route) = route {
            info!("Routing message to: {}", route);
            // Forward the message to the determined route
            self.nats_client.publish(&route, msg.payload.clone()).await?;
        } else {
            warn!("No route found for message: {}", input.id);
        }
        
        Ok(())
    }
    
    /// Determine the appropriate route for a message
    fn determine_route(&self, input: &InputEvent) -> Result<Option<String>, Box<dyn Error>> {
        // Extract routing key from the data (if available)
        // This is a simple implementation that looks for a "type" field
        let routing_key = if let Some(Value::String(type_value)) = input.data.get("type") {
            type_value.clone()
        } else {
            // If no type field is found, try to use metadata
            if let Some(Value::String(type_value)) = input.metadata.get("type") {
                type_value.clone()
            } else {
                // No routing key found
                return Ok(self.config.default_route.clone());
            }
        };
        
        // Look up the route in the routing rules
        if let Some(route) = self.config.routing_rules.get(&routing_key) {
            Ok(Some(route.clone()))
        } else {
            // Fall back to default route
            Ok(self.config.default_route.clone())
        }
    }
}
