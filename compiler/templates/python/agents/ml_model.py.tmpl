#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
{{agent_id}} - ML Model Agent for {{workflow_name}}
Generated by Kumeo compiler
"""

import os
import json
import logging
import asyncio
import pickle
import numpy as np
import pandas as pd
from typing import Dict, Any, Optional
import nats
from nats.aio.client import Client as NATS

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("{{agent_id}}")

class {{agent_id}}Agent:
    """ML Model Agent implementation for {{workflow_name}} workflow"""
    
    def __init__(self, nats_url: str = "nats://localhost:4222"):
        """Initialize the ML Model agent
        
        Args:
            nats_url: URL for the NATS server
        """
        self.nats_url = nats_url
        self.nats_client = None
        self.model_path = "{{model_path}}"
        self.input_topic = "{{input_topic}}"
        self.output_topic = "{{output_topic}}"
        self.model = None
        
    async def connect(self) -> None:
        """Connect to the NATS server"""
        logger.info(f"Connecting to NATS server at {self.nats_url}")
        self.nats_client = NATS()
        await self.nats_client.connect(servers=[self.nats_url])
        logger.info("Connected to NATS server")
        
    def load_model(self) -> None:
        """Load the ML model from disk"""
        logger.info(f"Loading ML model from {self.model_path}")
        try:
            with open(self.model_path, "rb") as f:
                self.model = pickle.load(f)
            logger.info("Model loaded successfully")
        except Exception as e:
            logger.error(f"Failed to load model: {e}")
            raise
            
    async def preprocess_input(self, data: Dict[str, Any]) -> np.ndarray:
        """Preprocess input data for the model
        
        Args:
            data: Input data as a dictionary
            
        Returns:
            Preprocessed data ready for model inference
        """
        # Convert input data to a format suitable for the model
        # This implementation will vary based on the specific model
        try:
            # Create a DataFrame from the input data
            df = pd.DataFrame([data])
            
            # Perform necessary preprocessing steps
            # - Handle missing values
            # - Scale/normalize features
            # - Encode categorical variables
            # - Feature engineering
            
            # Convert to numpy array for model input
            features = df.values
            
            return features
        except Exception as e:
            logger.error(f"Error preprocessing input: {e}")
            raise
            
    async def make_prediction(self, features: np.ndarray) -> Any:
        """Make a prediction using the loaded model
        
        Args:
            features: Preprocessed input features
            
        Returns:
            Model prediction result
        """
        if self.model is None:
            raise ValueError("Model has not been loaded")
            
        try:
            # Make prediction with the model
            prediction = self.model.predict(features)
            return prediction
        except Exception as e:
            logger.error(f"Error making prediction: {e}")
            raise
            
    async def postprocess_output(self, prediction: Any, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Postprocess model output to create response
        
        Args:
            prediction: Raw model prediction
            input_data: Original input data
            
        Returns:
            Formatted output event
        """
        # Format the prediction into the expected output structure
        if isinstance(prediction, np.ndarray):
            prediction = prediction.tolist()
            
        output = {
            "id": input_data.get("id", ""),
            "data": input_data.get("data", {}),
            "metadata": input_data.get("metadata", {}),
            "prediction": prediction
        }
        
        return output
            
    async def process_message(self, msg) -> None:
        """Process a single message from NATS
        
        Args:
            msg: NATS message
        """
        try:
            # Parse the input event
            input_event = json.loads(msg.data.decode())
            logger.info(f"Processing message with ID: {input_event.get('id', 'unknown')}")
            
            # Preprocess the input data
            features = await self.preprocess_input(input_event.get("data", {}))
            
            # Make prediction
            prediction = await self.make_prediction(features)
            
            # Postprocess and format output
            output_event = await self.postprocess_output(prediction, input_event)
            
            # Publish the result
            await self.nats_client.publish(
                self.output_topic,
                json.dumps(output_event).encode()
            )
            
            logger.info(f"Published prediction result to {self.output_topic}")
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            
    async def run(self) -> None:
        """Start the agent's message processing loop"""
        logger.info(f"Starting {{agent_id}} ML Model agent for workflow {{workflow_name}}")
        
        # Load the model
        self.load_model()
        
        # Connect to NATS
        await self.connect()
        
        # Subscribe to the input topic
        sub = await self.nats_client.subscribe(self.input_topic, cb=self.process_message)
        logger.info(f"Subscribed to {self.input_topic}")
        
        # Keep the agent running
        try:
            while True:
                await asyncio.sleep(1)
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
        finally:
            # Unsubscribe and close connection
            await sub.unsubscribe()
            await self.nats_client.close()
            
def main():
    """Main entry point for the agent"""
    # Get NATS URL from environment or use default
    nats_url = os.environ.get("NATS_URL", "nats://localhost:4222")
    
    # Create and run the agent
    agent = {{agent_id}}Agent(nats_url=nats_url)
    
    try:
        asyncio.run(agent.run())
    except KeyboardInterrupt:
        logger.info("Agent stopped by user")
    except Exception as e:
        logger.error(f"Agent stopped due to error: {e}")
        
if __name__ == "__main__":
    main()
