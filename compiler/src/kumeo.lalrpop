use std::str::FromStr;
use std::collections::HashMap;
use crate::ast::{Program, Workflow, Source, Target, Context, Agent, AgentType, Argument, Value};

// Define grammar that directly parses strings, not using our Logos lexer
grammar;

pub Program: Program = {
    <workflows:Workflow*> => {
        let mut program = Program::new();
        program.workflows = workflows;
        program
    }
};

Workflow: Workflow = {
    "workflow" <name:Identifier> "{" 
        <source:SourceDef?> 
        <target:TargetDef?> 
        <context:ContextDef?>
        <agents:AgentsDef> 
    "}" => Workflow {
        name: name,
        source: source,
        target: target,
        context: context,
        preprocessors: None,
        agents: agents,
        monitor: None,
        deployment: None,
    }
};

SourceDef: Source = {
    "source" ":" <source_value:SourceValue> => source_value
};

TargetDef: Target = {
    "target" ":" <target_value:TargetValue> => target_value
};

AgentsDef: Vec<Agent> = {
    "agents" ":" "[" <agents:Agent*> "]" => agents
};

SourceValue: Source = {
    <name:Identifier> "(" <topic:StringLiteral> ")" => 
        match name.as_str() {
            "NATS" => Source::NATS(topic, None),
            "HTTP" => Source::HTTP(topic, None),
            "Kafka" => Source::Kafka(topic, None),
            "MQTT" => Source::MQTT(topic, None),
            _ => Source::Custom(name, vec![Value::String(topic)])
        }
};

TargetValue: Target = {
    <name:Identifier> "(" <topic:StringLiteral> ")" => 
        match name.as_str() {
            "NATS" => Target::NATS(topic, None),
            "HTTP" => Target::HTTP(topic, None),
            "Kafka" => Target::Kafka(topic, None),
            "MQTT" => Target::MQTT(topic, None),
            _ => Target::Custom(name, vec![Value::String(topic)])
        }
};

Agent: Agent = {
    <agent_type:AgentType> "(" <args:Arguments> ")" => {
        let mut id = None;
        let mut config = Vec::new();
        
        for arg in args {
            if let Argument::Named(name, Value::String(value)) = &arg {
                if name == "id" {
                    id = Some(value.clone());
                } else {
                    config.push(arg.clone());
                }
            } else {
                config.push(arg.clone());
            }
        }
        
        Agent {
            id,
            agent_type,
            config,
        }
    }
};

// Add support for comma-separated arguments
Arguments: Vec<Argument> = {
    <head:Argument> <tail:("," Argument)*> => {
        let mut args = vec![head];
        args.extend(tail.into_iter().map(|(_, arg)| arg));
        args
    },
    => Vec::new()
};

AgentType: AgentType = {
    "LLM" => AgentType::LLM,
    "MLModel" => AgentType::MLModel,
    "BayesianNetwork" => AgentType::BayesianNetwork,
    <name:Identifier> => AgentType::Custom(name)
};

// Add support for Context
ContextDef: Context = {
    "context" ":" "KnowledgeBase" "(" <name:StringLiteral> ")" => {
        Context::KnowledgeBase(name, None)
    },
    "context" ":" "BayesianNetwork" "(" <name:StringLiteral> ")" => {
        Context::BayesianNetwork(name, None)
    },
    "context" ":" "Database" "(" <db_type:StringLiteral> "," <conn_string:StringLiteral> ")" => {
        Context::Database(db_type, conn_string)
    },
    "context" ":" <name:Identifier> "(" <args:Arguments> ")" => {
        Context::Custom(name, args.into_iter().map(|a| match a {
            Argument::Named(_, v) => v,
            Argument::Positional(v) => v
        }).collect())
    }
};

Argument: Argument = {
    <name:Identifier> ":" <value:StringLiteral> => 
        Argument::Named(name, Value::String(value)),
};

Identifier: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

StringLiteral: String = <s:r#""([^"\\]|\\.)*""#> => {
    let content = &s[1..s.len()-1]; // Remove quotes
    content.to_string()
};
