use super::ast::*;
use super::lexer::{Token, TokenWithContext};
use std::collections::HashMap;

// Grammar for Kumeo language
grammar<'kumeo>;

// The root production
pub Workflow = {
    items: Vec<Item> => {
        let mut workflow = Workflow {
            name: "main".to_string(),
            source: None,
            target: None,
            context: None,
            preprocessors: None,
            agents: vec![],
            monitor: None,
        };
        
        for item in items {
            match item {
                Item::Agent(a) => workflow.agents.push(a),
                Item::Config(c) => {
                    if workflow.context.is_none() {
                        workflow.context = Some(Context {
                            config: c,
                            models: HashMap::new(),
                            schemas: HashMap::new(),
                        });
                    }
                },
                Item::Source(s) => workflow.source = Some(s),
                Item::Target(t) => workflow.target = Some(t),
            }
        }
        
        workflow
    }
};

// Top-level items in a workflow
Item: Item = {
    Agent => Item::Agent(<>),
    Config => Item::Config(<>),
    Source => Item::Source(<>),
    Target => Item::Target(<>),
};

// Agent definition
Agent: Agent = {
    <agent_type: AgentType> <id: Ident> <_: LeftBrace>
    <config: KeyValuePairs>
    <_: RightBrace>
    => {
        let mut agent = Agent {
            id: id.to_string(),
            agent_type,
            config: HashMap::new(),
            subscribe: Vec::new(),
            publish: Vec::new(),
            resources: None,
            secrets: None,
        };
        
        for (key, value) in config {
            match key.as_str() {
                "subscribe" => {
                    if let Value::Array(items) = value {
                        agent.subscribe = items.into_iter()
                            .filter_map(|v| v.as_string())
                            .collect();
                    }
                },
                "publish" => {
                    if let Value::Array(items) = value {
                        agent.publish = items.into_iter()
                            .filter_map(|v| v.as_string())
                            .collect();
                    }
                },
                _ => {
                    agent.config.insert(key, value);
                },
            }
        }
        
        agent
    }
};

// Agent types
AgentType: AgentType = {
    <t: (Token![DataProcessor] | Token![MLModel] | Token![LLM] | Token![Router] | Token![DecisionMatrix] | Token![HumanReview])> => {
        match t {
            Token::DataProcessor => AgentType::DataProcessor,
            Token::MLModel => AgentType::MLModel,
            Token::LLM => AgentType::LLM,
            Token::Router => AgentType::Router,
            Token::DecisionMatrix => AgentType::DecisionMatrix,
            Token::HumanReview => AgentType::HumanReview,
            _ => unreachable!(),
        }
    },
};

// Configuration section
Config: HashMap<String, Value> = {
    <Token![config]> <_: LeftBrace>
    <pairs: KeyValuePairs>
    <_: RightBrace>
    => pairs.into_iter().collect()
};

// Source definition
Source: Source = {
    <Token![source]> <id: Ident> <_: LeftBrace>
    <pairs: KeyValuePairs>
    <_: RightBrace>
    => {
        let mut source = Source {
            id: id.to_string(),
            r#type: "".to_string(),
            config: HashMap::new(),
        };
        
        for (key, value) in pairs {
            if key == "type" {
                if let Value::String(s) = value {
                    source.r#type = s;
                }
            } else {
                source.config.insert(key, value);
            }
        }
        
        source
    }
};

// Target definition (similar to Source)
Target: Target = {
    <Token![target]> <id: Ident> <_: LeftBrace>
    <pairs: KeyValuePairs>
    <_: RightBrace>
    => {
        let mut target = Target {
            id: id.to_string(),
            r#type: "".to_string(),
            config: HashMap::new(),
        };
        
        for (key, value) in pairs {
            if key == "type" {
                if let Value::String(s) = value {
                    target.r#type = s;
                }
            } else {
                target.config.insert(key, value);
            }
        }
        
        target
    }
};

// Key-value pairs for configurations
KeyValuePairs: Vec<(String, Value)> = {
    => vec![],
    <mut pairs: KeyValuePairs> <key: Ident> <_: Token![:]> <value: Value> <_: Token![,]> => {
        pairs.push((key.to_string(), value));
        pairs
    },
    <mut pairs: KeyValuePairs> <key: Ident> <_: Token![:]> <value: Value> => {
        pairs.push((key.to_string(), value));
        pairs
    },
};

// Value types
Value: Value = {
    <s: StringLit> => Value::String(s.to_string()),
    <n: Number> => Value::Number(n),
    <Token![true]> => Value::Bool(true),
    <Token![false]> => Value::Bool(false),
    <Token![null]> => Value::Null,
    <_: LeftBracket> <elements: Comma<Value>> <_: RightBracket> => Value::Array(elements),
    <_: LeftBrace> <pairs: KeyValuePairs> <_: RightBrace> => {
        Value::Object(pairs.into_iter().collect())
    },
};

// Terminal rules
Ident: &'kumeo str = {
    <Token::Ident(s)> => s,
};

StringLit: &'kumeo str = {
    <Token::StringLit(s)> => s.trim_matches(|c| c == '"' || c == '\''),
};

Number: f64 = {
    <Token::Number(n)> => n,
};

// Token aliases for better readability
Token![config] = { Token::Config };
Token![source] = { Token::Source };
Token![target] = { Token::Target };
Token![DataProcessor] = { Token::DataProcessor };
Token![MLModel] = { Token::MLModel };
Token![LLM] = { Token::LLM };
Token![Router] = { Token::Router };
Token![DecisionMatrix] = { Token::DecisionMatrix };
Token![HumanReview] = { Token::HumanReview };
Token![:] = { Token::Colon };
Token![,] = { Token::Comma };
Token![.] = { Token::Dot };
Token![=] = { Token::Assign };
Token![true] = { Token::True };
Token![false] = { Token::False };
Token![null] = { Token::Null };
LeftBrace = { Token::LeftBrace };
RightBrace = { Token::RightBrace };
LeftBracket = { Token::LeftBracket };
RightBracket = { Token::RightBracket };
LeftParen = { Token::LeftParen };
RightParen = { Token::RightParen };
