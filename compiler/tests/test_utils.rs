use std::path::{Path, PathBuf};
use tempfile::TempDir;
use kumeo_compiler::ast::{Agent, AgentType, Value, Argument, Workflow, Program};
use kumeo_compiler::codegen::CodeGenerator;
use std::fs;
use anyhow::Context;

/// Helper function to create a test agent
pub fn create_test_agent() -> Agent {
    Agent {
        id: Some("test_agent".to_string()),
        agent_type: AgentType::LLM,
        config: vec![
            Argument::Named("model".to_string(), Value::String("gpt-4".to_string())),
            Argument::Named("temperature".to_string(), Value::Number(0.7)),
        ],
    }
}

/// Helper function to create a test workflow
pub fn create_test_workflow() -> Workflow {
    Workflow {
        name: "test_workflow".to_string(),
        source: None,
        target: None,
        context: None,
        agents: vec![create_test_agent()],
        deployment: None,
        monitor: None,
        preprocessors: None, // Changed from vec![] to None as it expects Option<Vec<Agent>>
    }
}

/// Helper function to create a test program
pub fn create_test_program() -> Program {
    Program {
        workflows: vec![create_test_workflow()],
        subworkflows: vec![],
        integrations: vec![],
    }
}

/// Get the path to the templates directory
pub fn get_templates_dir() -> PathBuf {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // We're already in compiler/tests, so we just need to go up one level
    manifest_dir.parent().unwrap().join("templates")
}

/// Test environment for code generation
pub struct TestEnv {
    _temp_dir: TempDir,
    pub output_dir: PathBuf,
}

impl TestEnv {
    pub fn new() -> Self {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let output_dir = temp_dir.path().to_path_buf();
        
        // Create necessary subdirectories
        std::fs::create_dir_all(output_dir.join("src/agents")).expect("Failed to create agents dir");
        std::fs::create_dir_all(output_dir.join("kubernetes")).expect("Failed to create kubernetes dir");
        
        // Create a simple lib.rs file
        let lib_rs = output_dir.join("src/lib.rs");
        std::fs::write(lib_rs, "// Auto-generated by test utils").expect("Failed to create lib.rs");
        
        Self {
            _temp_dir: temp_dir,
            output_dir,
        }
    }
}

/// Helper function to create a test code generator using real templates
pub fn create_test_generator() -> (CodeGenerator, TestEnv) {
    let test_env = TestEnv::new();
    
    // Get the path to the real templates
    let templates_dir = get_templates_dir();
    
    // Create a glob pattern for all template files
    let template_glob = templates_dir.join("**/*.tmpl");
    let template_glob_str = template_glob.to_str().expect("Invalid template path");
    
    // Convert output_dir to string
    let output_dir_str = test_env.output_dir.to_str().expect("Invalid output directory path");
    
    // Create the generator with the real templates
    let generator = CodeGenerator::new(template_glob_str, output_dir_str)
        .expect("Failed to create test generator");
        
    (generator, test_env)
}
